import { AppRouteModel } from "../utils/route.model";
import { COURSES_ROUTES_PERMISSIONS_CONFIG, CoursesRoutePaths } from "./courses.constants";
import { CoursesController } from "./courses.controller";
import { HttpMethods } from "../enums/http-methods.enum";
import { AuthGuard } from "../auth/auth.guard";

export const getCoursesRoutes = ({
  coursesController,
  authGuard,
}: {
  coursesController: CoursesController;
  authGuard: AuthGuard;
}): AppRouteModel[] => [
  {
    method: HttpMethods.GET,
    path: CoursesRoutePaths.BASE,
    handler: coursesController.getAll,
    authConfig: {
      authMiddleware: authGuard.authenticate,
      permissionsMiddleware: authGuard.checkPermissions(COURSES_ROUTES_PERMISSIONS_CONFIG),
    },
  },
  {
    method: HttpMethods.GET,
    path: CoursesRoutePaths.BY_ID,
    handler: coursesController.getById,
    authConfig: {
      authMiddleware: authGuard.authenticate,
      permissionsMiddleware: authGuard.checkPermissions(COURSES_ROUTES_PERMISSIONS_CONFIG),
    },
  },
  {
    method: HttpMethods.POST,
    path: CoursesRoutePaths.BASE,
    handler: coursesController.create,
    authConfig: {
      authMiddleware: authGuard.authenticate,
      permissionsMiddleware: authGuard.checkPermissions(COURSES_ROUTES_PERMISSIONS_CONFIG),
    },
  },
  {
    method: HttpMethods.PATCH,
    path: CoursesRoutePaths.BY_ID,
    handler: coursesController.edit,
    authConfig: {
      authMiddleware: authGuard.authenticate,
      permissionsMiddleware: authGuard.checkPermissions(COURSES_ROUTES_PERMISSIONS_CONFIG),
    },
  },
  {
    method: HttpMethods.DELETE,
    path: CoursesRoutePaths.BY_ID,
    handler: coursesController.delete,
    authConfig: {
      authMiddleware: authGuard.authenticate,
      permissionsMiddleware: authGuard.checkPermissions(COURSES_ROUTES_PERMISSIONS_CONFIG),
    },
  },
];
import { CreateTableInput } from "@aws-sdk/client-dynamodb";
import { UserRoles } from "../users/enums/user.roles.enum";
import { UserDepartments } from "../users/enums/user.departments.enum";
import { PermissionsMiddlewareConfig } from "../auth/auth.guard";

export const COURSES_DATA_FILE_PATH = "data/courses.data.json";

export const COURSES_TABLE_NAME = "Courses";

export const COURSES_TABLE_PARAMS: CreateTableInput = {
  TableName: COURSES_TABLE_NAME,
  AttributeDefinitions: [{ AttributeName: "id", AttributeType: "S" }],
  KeySchema: [{ AttributeName: "id", KeyType: "HASH" }],
  ProvisionedThroughput: {
    ReadCapacityUnits: 1,
    WriteCapacityUnits: 1,
  },
  BillingMode: "PROVISIONED",
};

export const COURSES_ROUTE_NAMESPACE = "/courses";

export enum CoursesRoutePaths {
  BASE = "/",
  BY_ID = "/:id",
}

export const COURSES_ROUTES_PERMISSIONS_CONFIG: PermissionsMiddlewareConfig = {
  allowedRoles: [UserRoles.ADMINISTRATOR, UserRoles.MANAGER],
  allowedDepartments: [UserDepartments.MARKETING],
};
import { Handler } from "express";
import { CoursesService } from "./courses.service";
import { CreateCourseDto, EditCourseDto } from "./models/courses.dtos";
import { HttpStatusCodes } from "../enums/http-status-codes.enum";

export class CoursesController {
  constructor(private readonly coursesService: CoursesService) {}

  public getAll: Handler = async (req, res, next): Promise<void> => {
    try {
      const courses = await this.coursesService.getAll();
      res.status(HttpStatusCodes.OK).json({ courses }).end();
    } catch (error) {
      next(error);
    }
  };

  public getById: Handler = async (req, res, next): Promise<void> => {
    try {
      const course = await this.coursesService.getById(req.params.id);
      res.status(HttpStatusCodes.OK).json({ course }).end();
    } catch (error) {
      next(error);
    }
  };

  public create: Handler = async (req, res, next): Promise<void> => {
    const newCourse: CreateCourseDto = req.body;

    try {
      const createdCourse = await this.coursesService.create(newCourse);
      res.status(HttpStatusCodes.CREATED).json({ course: createdCourse }).end();
    } catch (error) {
      next(error);
    }
  };

  public edit: Handler = async (req, res, next): Promise<void> => {
    const editCourseDto: EditCourseDto = req.body;

    try {
      const updatedCourse = await this.coursesService.edit(req.params.id, editCourseDto);
      res.status(HttpStatusCodes.OK).json({ course: updatedCourse }).end();
    } catch (error) {
      next(error);
    }
  };

  public delete: Handler = async (req, res, next): Promise<void> => {
    try {
      await this.coursesService.delete(req.params.id);
      res.status(HttpStatusCodes.NO_CONTENT).end();
    } catch (error) {
      next(error);
    }
  };
}
export enum CourseLearningFormats {
  BLENDED = "blended",
  RESIDENTIAL = "residential",
  VIRTUAL = "virtual",
  SELF_STUDY = "self-study",
  ONLINE = "online",
}
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { CoursesRepository } from "./courses.repository";
import { CoursesService } from "./courses.service";
import { CoursesController } from "./courses.controller";
import { getCoursesRoutes } from "./courses.routes";
import { SchemaValidator } from "../utils/schema-validator";
import { AuthGuard } from "../auth/auth.guard";
import { RoutingManager } from "../utils/routing-manager";
import { COURSES_ROUTE_NAMESPACE } from "./courses.constants";

export interface CoursesModule {}

export interface CoursesModuleDeps {
  authGuard: AuthGuard;
  dbClient: DynamoDBClient;
  routingManager: RoutingManager;
  schemaValidator: SchemaValidator;
}

export class CoursesModule {}

export const initCoursesModule = ({
  authGuard,
  dbClient,
  schemaValidator,
  routingManager,
}: CoursesModuleDeps): CoursesModule => {
  const coursesRepository = new CoursesRepository(dbClient);
  const coursesService = new CoursesService(coursesRepository, schemaValidator);
  const coursesController = new CoursesController(coursesService);

  const coursesRoutes = getCoursesRoutes({ coursesController, authGuard });
  routingManager.createRouter({ basePath: COURSES_ROUTE_NAMESPACE, routes: coursesRoutes });

  return {};
};
import { CoursesController } from "../courses.controller";
import { CoursesService } from "../courses.service";
import { HttpStatusCodes } from "../../enums/http-status-codes.enum";
import { Request, Response } from "express";
import { mockDatabaseError, mockValidationError } from "../../error-utils/enums/mock-errors";
import {
  mockCreateCourseDto,
  invalidCreateCourseDto,
  mockCourse,
  mockCourseId,
  mockCourses,
  mockEditCourseDto,
  mockEditedCourse,
  invalidEditCourseDto,
} from "./courses.mock-data";

describe("CoursesController", () => {
  let coursesController: CoursesController;
  let mockCoursesService: CoursesService;
  let mockRequest: Request;
  let mockRequestWithId: Request;
  let mockResponse: Response;
  let mockNext: jest.Mock;

  beforeEach(() => {
    mockCoursesService = {
      getAll: jest.fn(),
      getById: jest.fn(),
      create: jest.fn(),
      edit: jest.fn(),
      delete: jest.fn(),
    } as unknown as CoursesService;
    coursesController = new CoursesController(mockCoursesService);
    mockRequest = {} as Request;
    mockRequestWithId = { params: { id: mockCourseId } } as unknown as Request;
    mockResponse = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn().mockReturnThis(),
      end: jest.fn(),
    } as unknown as Response;
    mockNext = jest.fn();
  });

  describe("getAll method", () => {
    it("should return all courses", async () => {
      jest.spyOn(mockCoursesService, "getAll").mockResolvedValue(mockCourses);

      await coursesController.getAll(mockRequest, mockResponse, mockNext);

      expect(mockResponse.status).toHaveBeenCalledWith(HttpStatusCodes.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({ courses: mockCourses });
      expect(mockResponse.end).toHaveBeenCalled();
      expect(mockNext).not.toHaveBeenCalled();
    });

    it("should handle error and call next", async () => {
      jest.spyOn(mockCoursesService, "getAll").mockRejectedValue(mockDatabaseError);

      await coursesController.getAll(mockRequest, mockResponse, mockNext);

      expect(mockNext).toHaveBeenCalledWith(mockDatabaseError);
    });
  });

  describe("getById method", () => {
    it("should get a course by id", async () => {
      jest.spyOn(mockCoursesService, "getById").mockResolvedValue(mockCourse);

      await coursesController.getById(mockRequestWithId, mockResponse, mockNext);

      expect(mockCoursesService.getById).toHaveBeenCalledWith(mockCourseId);
      expect(mockResponse.status).toHaveBeenCalledWith(HttpStatusCodes.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({ course: mockCourse });
      expect(mockResponse.end).toHaveBeenCalled();
      expect(mockNext).not.toHaveBeenCalled();
    });

    it("should handle error during getById", async () => {
      jest.spyOn(mockCoursesService, "getById").mockRejectedValue(mockDatabaseError);

      await coursesController.getById(mockRequestWithId, mockResponse, mockNext);

      expect(mockCoursesService.getById).toHaveBeenCalledWith(mockCourseId);
      expect(mockNext).toHaveBeenCalledWith(mockDatabaseError);
    });
  });

  describe("create method", () => {
    it("should create a new course", async () => {
      mockRequest.body = mockCreateCourseDto;

      jest.spyOn(mockCoursesService, "create").mockResolvedValue(mockCourse);

      await coursesController.create(mockRequest, mockResponse, mockNext);

      expect(mockCoursesService.create).toHaveBeenCalledWith(mockCreateCourseDto);
      expect(mockResponse.status).toHaveBeenCalledWith(HttpStatusCodes.CREATED);
      expect(mockResponse.json).toHaveBeenCalledWith({ course: mockCourse });
      expect(mockResponse.end).toHaveBeenCalled();
      expect(mockNext).not.toHaveBeenCalled();
    });

    it("should handle error during create", async () => {
      mockRequest.body = invalidCreateCourseDto;

      jest.spyOn(mockCoursesService, "create").mockRejectedValue(mockValidationError);

      await coursesController.create(mockRequest, mockResponse, mockNext);

      expect(mockCoursesService.create).toHaveBeenCalledWith(invalidCreateCourseDto);
      expect(mockNext).toHaveBeenCalledWith(mockValidationError);
    });
  });

  describe("edit method", () => {
    it("should edit a course", async () => {
      mockRequestWithId.body = mockEditCourseDto;

      jest.spyOn(mockCoursesService, "edit").mockResolvedValue(mockEditedCourse);

      await coursesController.edit(mockRequestWithId, mockResponse, mockNext);

      expect(mockCoursesService.edit).toHaveBeenCalledWith(mockCourseId, mockEditCourseDto);
      expect(mockResponse.status).toHaveBeenCalledWith(HttpStatusCodes.OK);
      expect(mockResponse.json).toHaveBeenCalledWith({ course: mockEditedCourse });
      expect(mockResponse.end).toHaveBeenCalled();
      expect(mockNext).not.toHaveBeenCalled();
    });

    it("should handle validation error during edit", async () => {
      mockRequestWithId.body = invalidEditCourseDto;

      jest.spyOn(mockCoursesService, "edit").mockRejectedValue(mockValidationError);

      await coursesController.edit(mockRequestWithId, mockResponse, mockNext);

      expect(mockCoursesService.edit).toHaveBeenCalledWith(mockCourseId, invalidEditCourseDto);
      expect(mockNext).toHaveBeenCalledWith(mockValidationError);
    });

    it("should handle error during edit", async () => {
      mockRequestWithId.body = mockEditCourseDto;

      jest.spyOn(mockCoursesService, "edit").mockRejectedValue(mockDatabaseError);

      await coursesController.edit(mockRequestWithId, mockResponse, mockNext);

      expect(mockCoursesService.edit).toHaveBeenCalledWith(mockCourseId, mockEditCourseDto);
      expect(mockNext).toHaveBeenCalledWith(mockDatabaseError);
    });
  });

  describe("delete method", () => {
    it("should delete a course", async () => {
      jest.spyOn(mockCoursesService, "delete").mockResolvedValue();

      await coursesController.delete(mockRequestWithId, mockResponse, mockNext);

      expect(mockCoursesService.delete).toHaveBeenCalledWith(mockCourseId);
      expect(mockResponse.status).toHaveBeenCalledWith(HttpStatusCodes.NO_CONTENT);
      expect(mockResponse.end).toHaveBeenCalled();
      expect(mockNext).not.toHaveBeenCalled();
    });

    it("should handle error during delete", async () => {
      jest.spyOn(mockCoursesService, "delete").mockRejectedValue(mockDatabaseError);

      await coursesController.delete(mockRequestWithId, mockResponse, mockNext);

      expect(mockCoursesService.delete).toHaveBeenCalledWith(mockCourseId);
      expect(mockNext).toHaveBeenCalledWith(mockDatabaseError);
    });
  });
});
import { CoursesService } from "../courses.service";
import { SchemaValidator } from "../../utils/schema-validator";
import { CoursesRepository } from "../courses.repository";
import { createCourseSchema, editCourseSchema } from "../models/courses.schemas";
import { mockDatabaseError, mockValidationError } from "../../error-utils/enums/mock-errors";
import {
  invalidCourseId,
  invalidCreateCourseDto,
  invalidEditCourseDto,
  mockCourse,
  mockCourseId,
  mockCourses,
  mockCreateCourseDto,
  mockEditCourseDto,
  mockEditedCourse,
} from "./courses.mock-data";

describe("CoursesService", () => {
  let coursesService: CoursesService;
  let mockCoursesRepository: CoursesRepository;
  let mockSchemaValidator: SchemaValidator;

  beforeEach(() => {
    mockCoursesRepository = {
      getAll: jest.fn(),
      getById: jest.fn(),
      create: jest.fn(),
      edit: jest.fn(),
      delete: jest.fn(),
    } as unknown as CoursesRepository;

    mockSchemaValidator = {
      validateSchema: jest.fn(),
    } as unknown as SchemaValidator;

    coursesService = new CoursesService(mockCoursesRepository, mockSchemaValidator);
  });

  describe("getAll method", () => {
    it("should return all courses", async () => {
      jest.spyOn(mockCoursesRepository, "getAll").mockResolvedValue(mockCourses);

      const result = await coursesService.getAll();

      expect(result).toEqual(mockCourses);
      expect(mockCoursesRepository.getAll).toHaveBeenCalled();
    });

    it("should throw an error on repository error", async () => {
      jest.spyOn(mockCoursesRepository, "getAll").mockRejectedValue(mockDatabaseError);

      await expect(coursesService.getAll()).rejects.toThrow(mockDatabaseError);
    });
  });

  describe("getById method", () => {
    it("should return a course by id", async () => {
      jest.spyOn(mockCoursesRepository, "getById").mockResolvedValue(mockCourse);

      const result = await coursesService.getById(mockCourseId);

      expect(result).toEqual(mockCourse);
      expect(mockCoursesRepository.getById).toHaveBeenCalledWith(mockCourseId);
    });

    it("should throw an error for invalid course id", async () => {
      jest.spyOn(mockCoursesRepository, "getById").mockRejectedValue(mockDatabaseError);

      await expect(coursesService.getById(invalidCourseId)).rejects.toThrow(mockDatabaseError);

      expect(mockCoursesRepository.getById).toHaveBeenCalledWith(invalidCourseId);
    });

    it("should throw an error on repository error", async () => {
      jest.spyOn(mockCoursesRepository, "getById").mockRejectedValue(mockDatabaseError);

      await expect(coursesService.getById(mockCourseId)).rejects.toThrow(mockDatabaseError);
    });
  });

  describe("create method", () => {
    it("should create a new course", async () => {
      jest.spyOn(mockCoursesRepository, "create").mockResolvedValue(mockCourse);

      await expect(coursesService.create(mockCreateCourseDto)).resolves.toEqual(mockCourse);
      expect(mockSchemaValidator.validateSchema).toHaveBeenCalledWith(
        createCourseSchema,
        mockCreateCourseDto
      );
      expect(mockCoursesRepository.create).toHaveBeenCalledWith(mockCreateCourseDto);
    });

    it("should throw an error for invalid createCourseDto", async () => {
      jest.spyOn(mockSchemaValidator, "validateSchema").mockImplementation(() => {
        throw mockValidationError;
      });

      await expect(coursesService.create(invalidCreateCourseDto)).rejects.toThrow(
        mockValidationError
      );
      expect(mockSchemaValidator.validateSchema).toHaveBeenCalledWith(
        createCourseSchema,
        invalidCreateCourseDto
      );
      expect(mockCoursesRepository.create).not.toHaveBeenCalled();
    });

    it("should throw an error on repository error", async () => {
      jest.spyOn(mockCoursesRepository, "create").mockRejectedValue(mockDatabaseError);

      await expect(coursesService.create(mockCreateCourseDto)).rejects.toThrow(mockDatabaseError);
    });
  });

  describe("edit method", () => {
    it("should edit an existing course", async () => {
      jest.spyOn(mockCoursesRepository, "getById").mockResolvedValue(mockCourse);
      jest.spyOn(mockCoursesRepository, "edit").mockResolvedValue(mockEditedCourse);

      await expect(coursesService.edit(mockCourseId, mockEditCourseDto)).resolves.toEqual(
        mockEditedCourse
      );
      expect(mockSchemaValidator.validateSchema).toHaveBeenCalledWith(
        editCourseSchema,
        mockEditCourseDto
      );
      expect(mockCoursesRepository.getById).toHaveBeenCalledWith(mockCourseId);
      expect(mockCoursesRepository.edit).toHaveBeenCalledWith(mockCourseId, mockEditCourseDto);
    });

    it("should throw an error for invalid editCourseDto", async () => {
      jest.spyOn(mockCoursesRepository, "getById").mockResolvedValue(mockCourse);
      jest.spyOn(mockSchemaValidator, "validateSchema").mockImplementation(() => {
        throw mockValidationError;
      });

      await expect(coursesService.edit(mockCourseId, invalidEditCourseDto)).rejects.toThrow(
        mockValidationError
      );
      expect(mockCoursesRepository.getById).toHaveBeenCalledWith(mockCourseId);
      expect(mockSchemaValidator.validateSchema).toHaveBeenCalledWith(
        editCourseSchema,
        invalidEditCourseDto
      );
      expect(mockCoursesRepository.edit).not.toHaveBeenCalled();
    });

    it("should throw an error for non-existing course", async () => {
      jest.spyOn(mockCoursesRepository, "getById").mockRejectedValue(mockDatabaseError);

      await expect(coursesService.edit(mockCourseId, mockEditCourseDto)).rejects.toThrow(
        mockDatabaseError
      );
      expect(mockCoursesRepository.getById).toHaveBeenCalledWith(mockCourseId);
      expect(mockSchemaValidator.validateSchema).not.toHaveBeenCalled();
      expect(mockCoursesRepository.edit).not.toHaveBeenCalled();
    });

    it("should throw an error on repository error", async () => {
      jest.spyOn(mockCoursesRepository, "getById").mockResolvedValue(mockCourse);
      jest.spyOn(mockCoursesRepository, "edit").mockRejectedValue(mockDatabaseError);

      await expect(coursesService.edit(mockCourseId, mockEditCourseDto)).rejects.toThrow(
        mockDatabaseError
      );
      expect(mockSchemaValidator.validateSchema).toHaveBeenCalledWith(
        editCourseSchema,
        mockEditCourseDto
      );
      expect(mockCoursesRepository.getById).toHaveBeenCalledWith(mockCourseId);
      expect(mockCoursesRepository.edit).toHaveBeenCalledWith(mockCourseId, mockEditCourseDto);
    });
  });

  describe("delete method", () => {
    it("should delete an existing course", async () => {
      jest.spyOn(mockCoursesRepository, "getById").mockResolvedValue(mockCourse);
      jest.spyOn(mockCoursesRepository, "delete").mockResolvedValue(undefined);

      await expect(coursesService.delete(mockCourseId)).resolves.toBeUndefined();
      expect(mockCoursesRepository.getById).toHaveBeenCalledWith(mockCourseId);
      expect(mockCoursesRepository.delete).toHaveBeenCalledWith(mockCourseId);
    });

    it("should throw an error for non-existing course", async () => {
      jest.spyOn(mockCoursesRepository, "getById").mockRejectedValue(mockDatabaseError);

      await expect(coursesService.delete(mockCourseId)).rejects.toThrow(mockDatabaseError);
      expect(mockCoursesRepository.getById).toHaveBeenCalledWith(mockCourseId);
      expect(mockCoursesRepository.delete).not.toHaveBeenCalled();
    });

    it("should throw an error on repository error", async () => {
      jest.spyOn(mockCoursesRepository, "getById").mockResolvedValue(mockCourse);
      jest.spyOn(mockCoursesRepository, "delete").mockRejectedValue(mockDatabaseError);

      await expect(coursesService.delete(mockCourseId)).rejects.toThrow(mockDatabaseError);
      expect(mockCoursesRepository.getById).toHaveBeenCalledWith(mockCourseId);
      expect(mockCoursesRepository.delete).toHaveBeenCalledWith(mockCourseId);
    });
  });
});
import { marshall } from "@aws-sdk/util-dynamodb";
import { CourseLearningFormats } from "../enums/course.learning-formats.enum";
import { CreateCourseDto, EditCourseDto } from "../models/courses.dtos";
import { CourseModel } from "../models/course.model";

export const mockCourseId = "mockCourseId";
export const invalidCourseId = "invalidCourseId";
export const editedTitle = "edited title";

export const invalidCreateCourseDto = {} as CreateCourseDto;
export const mockCreateCourseDto: CreateCourseDto = {
  title: "Sample Course",
  topic: "Sample topic",
  bestseller: false,
  learningFormats: [CourseLearningFormats.BLENDED],
  startDate: "12-01-2024",
};

export const invalidEditCourseDto: EditCourseDto = {};
export const mockEditCourseDto: EditCourseDto = {
  title: editedTitle,
};

export const mockCourse: CourseModel = {
  id: "1",
  ...mockCreateCourseDto,
};

export const mockEditedCourse: CourseModel = {
  ...mockCourse,
  title: editedTitle,
};

export const mockCourses = [mockCourse];

export const mockCoursesScanResult = {
  Items: [marshall(mockCourse)],
};
export const mockCoursesGetItemResult = {
  Item: marshall(mockCourse),
};
export const mockGetItemNullResult = {
  Item: null,
};

export const mockCoursesPutItemResult = {};
export const mockCoursesUpdateItemResult = {};
export const mockCoursesDeleteItemResult = {};
import {
  DynamoDBClient,
  ScanCommand,
  GetItemCommand,
  PutItemCommand,
  UpdateItemCommand,
  DeleteItemCommand,
} from "@aws-sdk/client-dynamodb";
import { DatabaseError } from "../../error-utils/custom-errors/database.error";
import { CoursesRepository } from "../courses.repository";
import {
  mockCourse,
  mockCourseId,
  mockCreateCourseDto,
  mockCoursesDeleteItemResult,
  mockEditCourseDto,
  mockGetItemNullResult,
  mockCoursesGetItemResult,
  mockCoursesPutItemResult,
  mockCoursesScanResult,
  mockCoursesUpdateItemResult,
} from "./courses.mock-data";
import { mockDatabaseError } from "../../error-utils/enums/mock-errors";

describe("CoursesRepository", () => {
  const mockDynamoDBClient = {
    send: jest.fn(),
  };

  const coursesRepository = new CoursesRepository(mockDynamoDBClient as unknown as DynamoDBClient);

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("getAll method", () => {
    it("should get all courses successfully", async () => {
      mockDynamoDBClient.send.mockResolvedValue(mockCoursesScanResult);

      const result = await coursesRepository.getAll();

      expect(mockDynamoDBClient.send).toHaveBeenCalledWith(expect.any(ScanCommand));
      expect(result).toEqual([mockCourse]);
    });

    it("should throw DatabaseError on general database error", async () => {
      mockDynamoDBClient.send.mockRejectedValue(mockDatabaseError);

      await expect(coursesRepository.getAll()).rejects.toThrow(DatabaseError);

      expect(mockDynamoDBClient.send).toHaveBeenCalledWith(expect.any(ScanCommand));
    });
  });

  describe("getById method", () => {
    it("should get course by id successfully", async () => {
      mockDynamoDBClient.send.mockResolvedValue(mockCoursesGetItemResult);

      const result = await coursesRepository.getById(mockCourseId);

      expect(mockDynamoDBClient.send).toHaveBeenCalledWith(expect.any(GetItemCommand));
      expect(result).toEqual(mockCourse);
    });

    it("should throw DatabaseError when course is not found", async () => {
      mockDynamoDBClient.send.mockResolvedValue(mockGetItemNullResult);

      await expect(coursesRepository.getById("nonexistentcourse")).rejects.toThrow(DatabaseError);

      expect(mockDynamoDBClient.send).toHaveBeenCalledWith(expect.any(GetItemCommand));
    });

    it("should throw DatabaseError on general database error", async () => {
      mockDynamoDBClient.send.mockRejectedValue(mockDatabaseError);

      await expect(coursesRepository.getById(mockCourseId)).rejects.toThrow(DatabaseError);

      expect(mockDynamoDBClient.send).toHaveBeenCalledWith(expect.any(GetItemCommand));
    });
  });

  describe("create method", () => {
    it("should create a course successfully", async () => {
      mockDynamoDBClient.send.mockResolvedValue(mockCoursesPutItemResult);
      jest.spyOn(coursesRepository, "getById").mockResolvedValue(mockCourse);

      const result = await coursesRepository.create(mockCreateCourseDto);

      expect(mockDynamoDBClient.send).toHaveBeenCalledWith(expect.any(PutItemCommand));
      expect(coursesRepository.getById).toHaveBeenCalledWith(expect.any(String));
      expect(result).toEqual(mockCourse);
    });

    it("should throw DatabaseError on general database error during create", async () => {
      mockDynamoDBClient.send.mockRejectedValue(mockDatabaseError);

      await expect(coursesRepository.create(mockCreateCourseDto)).rejects.toThrow(DatabaseError);

      expect(mockDynamoDBClient.send).toHaveBeenCalledWith(expect.any(PutItemCommand));
      expect(coursesRepository.getById).not.toHaveBeenCalled();
    });
  });

  describe("edit method", () => {
    it("should edit a course successfully", async () => {
      mockDynamoDBClient.send.mockResolvedValue(mockCoursesUpdateItemResult);
      jest.spyOn(coursesRepository, "getById").mockResolvedValue(mockCourse);

      const result = await coursesRepository.edit(mockCourseId, mockEditCourseDto);

      expect(mockDynamoDBClient.send).toHaveBeenCalledWith(expect.any(UpdateItemCommand));
      expect(coursesRepository.getById).toHaveBeenCalledWith(mockCourseId);
      expect(result).toEqual(mockCourse);
    });

    it("should throw DatabaseError on general database error during edit", async () => {
      mockDynamoDBClient.send.mockRejectedValue(mockDatabaseError);

      await expect(coursesRepository.edit(mockCourseId, mockEditCourseDto)).rejects.toThrow(
        DatabaseError
      );

      expect(mockDynamoDBClient.send).toHaveBeenCalledWith(expect.any(UpdateItemCommand));
      expect(coursesRepository.getById).not.toHaveBeenCalled();
    });
  });

  describe("delete method", () => {
    it("should delete a course successfully", async () => {
      mockDynamoDBClient.send.mockResolvedValue(mockCoursesDeleteItemResult);

      await coursesRepository.delete(mockCourseId);

      expect(mockDynamoDBClient.send).toHaveBeenCalledWith(expect.any(DeleteItemCommand));
    });

    it("should throw DatabaseError on general database error during delete", async () => {
      mockDynamoDBClient.send.mockRejectedValue(mockDatabaseError);

      await expect(coursesRepository.delete(mockCourseId)).rejects.toThrow(DatabaseError);

      expect(mockDynamoDBClient.send).toHaveBeenCalledWith(expect.any(DeleteItemCommand));
    });
  });
});
import { CourseModel } from "./models/course.model";
import { SchemaValidator } from "../utils/schema-validator";
import { CreateCourseDto, EditCourseDto } from "./models/courses.dtos";
import { CoursesRepository } from "./courses.repository";
import { createCourseSchema, editCourseSchema } from "./models/courses.schemas";

export class CoursesService {
  constructor(
    private readonly courseRepository: CoursesRepository,
    private readonly schemaValidator: SchemaValidator
  ) {}

  public getAll = async (): Promise<CourseModel[]> => {
    try {
      return await this.courseRepository.getAll();
    } catch (error) {
      throw error;
    }
  };

  public getById = async (id: string): Promise<CourseModel> => {
    try {
      return await this.courseRepository.getById(id);
    } catch (error) {
      throw error;
    }
  };

  public create = async (createCourseDto: CreateCourseDto): Promise<CourseModel> => {
    try {
      this.schemaValidator.validateSchema(createCourseSchema, createCourseDto);
      return await this.courseRepository.create(createCourseDto);
    } catch (error) {
      throw error;
    }
  };

  public edit = async (
    id: string,
    editCourseDto: EditCourseDto
  ): Promise<CourseModel | undefined> => {
    try {
      const itemToBeDeleted = await this.courseRepository.getById(id);
      if (itemToBeDeleted) {
        this.schemaValidator.validateSchema(editCourseSchema, editCourseDto);
        return await this.courseRepository.edit(id, editCourseDto);
      }
    } catch (error) {
      throw error;
    }
  };

  public delete = async (id: string): Promise<void> => {
    try {
      const itemToBeDeleted = await this.courseRepository.getById(id);
      if (itemToBeDeleted) {
        await this.courseRepository.delete(id);
      }
    } catch (error) {
      throw error;
    }
  };
}
import { CourseModel } from "./course.model";

export type CreateCourseDto = Omit<CourseModel, "id">;

export type EditCourseDto = Omit<Partial<CourseModel>, "id">;
import { CourseLearningFormats } from "../enums/course.learning-formats.enum";

export interface CourseModel {
  id: string;
  title: string;
  topic: string;
  learningFormats: CourseLearningFormats[];
  bestseller: boolean;
  startDate: string;
}
import Joi from "joi";
import { CourseLearningFormats } from "../enums/course.learning-formats.enum";

const VALID_LEARNING_FORMATS = Array.from(Object.values(CourseLearningFormats));

export const createCourseSchema = Joi.object({
  title: Joi.string().required(),
  topic: Joi.string().required(),
  learningFormats: Joi.array()
    .items(Joi.string().valid(...VALID_LEARNING_FORMATS))
    .min(1)
    .required(),
  bestseller: Joi.boolean().required(),
  startDate: Joi.string().isoDate().required(),
});

export const editCourseSchema = Joi.object({
  title: Joi.string(),
  topic: Joi.string(),
  learningFormats: Joi.array()
    .items(Joi.string().valid(...VALID_LEARNING_FORMATS))
    .min(1),
  bestseller: Joi.boolean(),
  startDate: Joi.string().isoDate(),
});
import {
  DynamoDBClient,
  ScanCommand,
  GetItemCommand,
  PutItemCommand,
  UpdateItemCommand,
  DeleteItemCommand,
  QueryCommandInput,
  PutItemCommandInput,
  UpdateItemCommandInput,
  DeleteItemCommandInput,
  GetItemCommandInput,
} from "@aws-sdk/client-dynamodb";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import { CourseModel } from "./models/course.model";
import { CreateCourseDto, EditCourseDto } from "./models/courses.dtos";
import { COURSES_TABLE_NAME } from "./courses.constants";
import { DatabaseError } from "../error-utils/custom-errors/database.error";
import { ErrorCodes } from "../error-utils/enums/error.codes.enum";
import { randomUUID } from "crypto";

export class CoursesRepository {
  constructor(private readonly dbClient: DynamoDBClient) {}

  public getAll = async (): Promise<CourseModel[]> => {
    try {
      const params: QueryCommandInput = {
        TableName: COURSES_TABLE_NAME,
      };

      const command = new ScanCommand(params);
      const result = await this.dbClient.send(command);

      return (result.Items?.map((item) => unmarshall(item)) || []) as unknown as CourseModel[];
    } catch (error) {
      throw new DatabaseError({
        message: "Error Fetching Courses",
        code: ErrorCodes.DATABASE_ERROR,
      });
    }
  };

  public getById = async (id: string): Promise<CourseModel> => {
    try {
      const params: GetItemCommandInput = {
        TableName: COURSES_TABLE_NAME,
        Key: marshall({
          id,
        }),
      };

      const command = new GetItemCommand(params);
      const result = await this.dbClient.send(command);

      if (!result.Item) {
        throw new DatabaseError({
          message: `Course With Id ${id} Not Found`,
          code: ErrorCodes.NOT_FOUND,
        });
      }

      return unmarshall(result.Item) as CourseModel;
    } catch (error) {
      throw new DatabaseError({
        message: `Course With Id ${id} Not Found`,
        code: ErrorCodes.NOT_FOUND,
      });
    }
  };

  public create = async (createCourseDto: CreateCourseDto): Promise<CourseModel> => {
    try {
      const id = randomUUID();

      const params: PutItemCommandInput = {
        TableName: COURSES_TABLE_NAME,
        Item: marshall({
          id,
          ...createCourseDto,
        }),
      };

      const command = new PutItemCommand(params);
      await this.dbClient.send(command);

      return this.getById(id);
    } catch (error) {
      throw new DatabaseError({
        message: "Error Creating Course",
        code: ErrorCodes.DATABASE_ERROR,
      });
    }
  };

  // The goal of this function is to help the `edit` method to identify
  // which fields of the given resource should be updated based on the fields provided
  // by the user in the request.
  // For example: if the user sends only `title` and `topic`, those are the only fields
  // that should be updated. This function will build the database request config params
  // based on this information
  private getUpdateConfig = (editCourseDto: EditCourseDto) => {
    const possibleAttributes: (keyof EditCourseDto)[] = [
      "title",
      "topic",
      "startDate",
      "learningFormats",
    ];

    const updateExpressionParts: string[] = [];

    const expressionAttributeValues: Record<string, any> = {};

    possibleAttributes.forEach((attribute, index) => {
      const attributeValue = editCourseDto[attribute];

      if (attributeValue !== undefined) {
        const prefix = updateExpressionParts.length === 0 ? "SET " : "";
        updateExpressionParts.push(`${prefix}${attribute} = :${attribute}`);
        expressionAttributeValues[`:${attribute}`] = attributeValue;
      }
    });

    const updateExpression = updateExpressionParts.join(", ");

    return { updateExpression, expressionAttributeValues };
  };

  public edit = async (id: string, editCourseDto: EditCourseDto): Promise<CourseModel> => {
    try {
      const { updateExpression, expressionAttributeValues } = this.getUpdateConfig(editCourseDto);

      const params: UpdateItemCommandInput = {
        TableName: COURSES_TABLE_NAME,
        Key: marshall({
          id,
        }),
        UpdateExpression: updateExpression,
        ExpressionAttributeValues: marshall(expressionAttributeValues),
      };

      const command = new UpdateItemCommand(params);
      await this.dbClient.send(command);

      return this.getById(id);
    } catch (error) {
      throw new DatabaseError({
        message: `Error Editing Course With Id ${id}`,
        code: ErrorCodes.DATABASE_ERROR,
      });
    }
  };

  public delete = async (id: string): Promise<void> => {
    try {
      const params: DeleteItemCommandInput = {
        TableName: COURSES_TABLE_NAME,
        Key: marshall({
          id,
        }),
      };

      const command = new DeleteItemCommand(params);
      await this.dbClient.send(command);
    } catch (error) {
      throw new DatabaseError({
        message: `Error Deleting Course With Id ${id}`,
        code: ErrorCodes.DATABASE_ERROR,
      });
    }
  };
}
